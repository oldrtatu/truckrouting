{"version":3,"sources":["RouterBox.js","excelFromJson.js","App.js","nearbyMarker.js","index.js"],"names":["RouteBoxer","this","R","prototype","box","path","range","grid_","latGrid_","lngGrid_","boxesX_","boxesY_","vertices","Array","window","google","maps","Polyline","getPath","getLength","i","length","getAt","getVertexCount","j","getVertex","buildGrid_","findIntersectingCells_","mergeIntersectingCells_","routeBounds","LatLngBounds","extend","routeBoundsCenter","getCenter","push","lat","rhumbDestinationPoint","getNorthEast","getSouthWest","unshift","lng","hintXY","getCellCoords_","markCell_","gridXY","getGridCoordsFromHint_","Math","abs","getGridIntersects_","latlng","x","y","hintlatlng","hint","start","end","startXY","endXY","edgePoint","edgeXY","brng","rhumbBearingTo","getGridIntersect_","fillInGridSquares_","gridLineLat","d","toRad","cos","startx","endx","cell","currentBox","getCellBounds_","mergeBoxesY_","mergeBoxesX_","LatLng","dist","parseFloat","lat1","lon1","lat2","dLat","dPhi","log","tan","PI","q","dLon","sin","lon2","isNaN","toDeg","dest","atan2","toBrng","Number","from_json","data","console","Object","keys","workBook","title","subject","author","wb","XLSX","utils","book_new","Props","Title","Subject","Author","CreatedDate","Date","createExcelWorkBook","workSheet","json_to_sheet","header","skipHeader","book_append_sheet","workBookOutput","write","bookType","type","Blob","stringToArrayBuffer","buffer","ArrayBuffer","view","Uint8Array","charCodeAt","concat","toConsumableArray","jsonFuel","Cad","Sheet2","MyMapComponent","withGoogleMap","props","react_default","a","createElement","lib","defaultZoom","defaultCenter","isMarkerShown","marker","map","item","index","key","position","draggable","onClick","handleShowInfo","showInfo","onCloseClick","site_id","Street","brand","directions","MapContainer","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","handleSelect","place","name","setState","from","location","undefined","to","handleSearch","state","distance","handleDirection","error","DirectionsService","route","origin","destination","travelMode","TravelMode","DRIVING","result","status","DirectionsStatus","OK","locations","containsMarker","gmarkers","routeBoxer","forEach","element","Marker","routes","overview_path","boxes","contains","getPosition","nearByMarker","calculateData","add","handleDistance","event","target","value","source","destinations","distanceService","DistanceMatrixService","total_location_length","total_location","total_destination","split_destination","splice","_loop","getDistanceMatrix","origins","res","rows","elements","destinationAddresses","objectSpread","Address","sort","b","text","duration","Site_Id","exportToExcel","exportData","href","URL","createObjectURL","_this2","Fragment","className","Geosuggest_esm","onSuggestSelect","placeholder","onChange","download","loadingElement","style","height","containerElement","mapElement","React","Component","ReactDOM","render","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.1c9b1e5c.chunk.js","sourcesContent":["/**\n * @name RouteBoxer\n * @version 1.0\n * @copyright (c) 2010 Google Inc.\n * @author Thor Mitchell\n *\n * @fileoverview The RouteBoxer class takes a path, such as the Polyline for a\n * route generated by a Directions request, and generates a set of LatLngBounds\n * objects that are guaranteed to contain every point within a given distance\n * of that route. These LatLngBounds objects can then be used to generate\n * requests to spatial search services that support bounds filtering (such as\n * the Google Maps Data API) in order to implement search along a route.\n * <br/><br/>\n * RouteBoxer overlays a grid of the specified size on the route, identifies\n * every grid cell that the route passes through, and generates a set of bounds\n * that cover all of these cells, and their nearest neighbours. Consequently\n * the bounds returned will extend up to ~3x the specified distance from the\n * route in places.\n */\n\n/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License. \n */\n\n/**\n * Creates a new RouteBoxer\n *\n * @constructor\n */\nfunction RouteBoxer() {\n    this.R = 6371; // earth's mean radius in km\n  }\n  \n  /**\n   * Generates boxes for a given route and distance\n   *\n   * @param {window.google.maps.LatLng[] | window.google.maps.Polyline} path The path along\n   *           which to create boxes. The path object can be either an Array of\n   *           window.google.maps.LatLng objects or a Maps API v2 or Maps API v3\n   *           window.google.maps.Polyline object.\n   * @param {Number} range The distance in kms around the route that the generated\n   *           boxes must cover.\n   * @return {window.google.maps.LatLngBounds[]} An array of boxes that covers the whole\n   *           path.\n   */\n  RouteBoxer.prototype.box = function (path, range) {\n    // Two dimensional array representing the cells in the grid overlaid on the path\n    this.grid_ = null;\n    \n    // Array that holds the latitude coordinate of each vertical grid line\n    this.latGrid_ = [];\n    \n    // Array that holds the longitude coordinate of each horizontal grid line  \n    this.lngGrid_ = [];\n    \n    // Array of bounds that cover the whole route formed by merging cells that\n    //  the route intersects first horizontally, and then vertically\n    this.boxesX_ = [];\n  \n    // Array of bounds that cover the whole route formed by merging cells that\n    //  the route intersects first vertically, and then horizontally\n    this.boxesY_ = [];\n    \n    // The array of LatLngs representing the vertices of the path\n    var vertices = null;\n  \n    // If necessary convert the path into an array of LatLng objects\n    if (path instanceof Array) {\n      // already an arry of LatLngs (eg. v3 overview_path)\n      vertices = path;\n    } else if (path instanceof window.google.maps.Polyline) {\n      if (path.getPath) {\n        // v3 Maps API Polyline object\n        vertices = new Array(path.getPath().getLength());\n        for (var i = 0; i < vertices.length; i++) {\n          vertices[i] = path.getPath().getAt(i);\n        }\n      } else {\n        // v2 Maps API Polyline object\n        vertices = new Array(path.getVertexCount());\n        for (var j = 0; j < vertices.length; j++) {\n          vertices[j] = path.getVertex(j);\n        }\n      }\n    }\n  \n    // Build the grid that is overlaid on the route\n    this.buildGrid_(vertices, range);\n    \n    // Identify the grid cells that the route intersects\n    this.findIntersectingCells_(vertices);\n    \n    // Merge adjacent intersected grid cells (and their neighbours) into two sets\n    //  of bounds, both of which cover them completely\n    this.mergeIntersectingCells_();\n  \n    // Return the set of merged bounds that has the fewest elements\n    return (this.boxesX_.length <= this.boxesY_.length ?\n            this.boxesX_ :\n            this.boxesY_);\n  };\n  \n  /**\n   * Generates boxes for a given route and distance\n   *\n   * @param {LatLng[]} vertices The vertices of the path over which to lay the grid\n   * @param {Number} range The spacing of the grid cells.\n   */\n  RouteBoxer.prototype.buildGrid_ = function (vertices, range) {\n  \n    // Create a LatLngBounds object that contains the whole path\n    var routeBounds = new window.google.maps.LatLngBounds();\n    for (var i = 0; i < vertices.length; i++) {\n      routeBounds.extend(vertices[i]);\n    }\n    \n    // Find the center of the bounding box of the path\n    var routeBoundsCenter = routeBounds.getCenter();\n    \n    // Starting from the center define grid lines outwards vertically until they\n    //  extend beyond the edge of the bounding box by more than one cell\n    this.latGrid_.push(routeBoundsCenter.lat());\n    \n    // Add lines from the center out to the north\n    this.latGrid_.push(routeBoundsCenter.rhumbDestinationPoint(0, range).lat());\n    for (i = 2; this.latGrid_[i - 2] < routeBounds.getNorthEast().lat(); i++) {\n      this.latGrid_.push(routeBoundsCenter.rhumbDestinationPoint(0, range * i).lat());\n    }\n  \n    // Add lines from the center out to the south  \n    for (i = 1; this.latGrid_[1] > routeBounds.getSouthWest().lat(); i++) {\n      this.latGrid_.unshift(routeBoundsCenter.rhumbDestinationPoint(180, range * i).lat());\n    }\n  \n    // Starting from the center define grid lines outwards horizontally until they\n    //  extend beyond the edge of the bounding box by more than one cell  \n    this.lngGrid_.push(routeBoundsCenter.lng());\n    \n    // Add lines from the center out to the east\n    this.lngGrid_.push(routeBoundsCenter.rhumbDestinationPoint(90, range).lng());\n    for (i = 2; this.lngGrid_[i - 2] < routeBounds.getNorthEast().lng(); i++) {\n      this.lngGrid_.push(routeBoundsCenter.rhumbDestinationPoint(90, range * i).lng());\n    }\n    \n    // Add lines from the center out to the west\n    for (i = 1; this.lngGrid_[1] > routeBounds.getSouthWest().lng(); i++) {\n      this.lngGrid_.unshift(routeBoundsCenter.rhumbDestinationPoint(270, range * i).lng());\n    }\n    \n    // Create a two dimensional array representing this grid\n    this.grid_ = new Array(this.lngGrid_.length);\n    for (i = 0; i < this.grid_.length; i++) {\n      this.grid_[i] = new Array(this.latGrid_.length);\n    }\n  };\n  \n  /**\n   * Find all of the cells in the overlaid grid that the path intersects\n   *\n   * @param {LatLng[]} vertices The vertices of the path\n   */\n  RouteBoxer.prototype.findIntersectingCells_ = function (vertices) {\n    // Find the cell where the path begins\n    var hintXY = this.getCellCoords_(vertices[0]);\n    \n    // Mark that cell and it's neighbours for inclusion in the boxes\n    this.markCell_(hintXY);\n  \n    // Work through each vertex on the path identifying which grid cell it is in\n    for (var i = 1; i < vertices.length; i++) {\n      // Use the known cell of the previous vertex to help find the cell of this vertex\n      var gridXY = this.getGridCoordsFromHint_(vertices[i], vertices[i - 1], hintXY);\n      \n      if (gridXY[0] === hintXY[0] && gridXY[1] === hintXY[1]) {\n        // This vertex is in the same cell as the previous vertex\n        // The cell will already have been marked for inclusion in the boxes\n        continue;\n      \n      } else if ((Math.abs(hintXY[0] - gridXY[0]) === 1 && hintXY[1] === gridXY[1]) ||\n          (hintXY[0] === gridXY[0] && Math.abs(hintXY[1] - gridXY[1]) === 1)) {\n        // This vertex is in a cell that shares an edge with the previous cell\n        // Mark this cell and it's neighbours for inclusion in the boxes\n        this.markCell_(gridXY);\n        \n      } else {\n        // This vertex is in a cell that does not share an edge with the previous\n        //  cell. This means that the path passes through other cells between\n        //  this vertex and the previous vertex, and we must determine which cells\n        //  it passes through\n        this.getGridIntersects_(vertices[i - 1], vertices[i], hintXY, gridXY);\n      }\n      \n      // Use this cell to find and compare with the next one\n      hintXY = gridXY;\n    }\n  };\n  \n  /**\n   * Find the cell a path vertex is in by brute force iteration over the grid\n   *\n   * @param {LatLng[]} latlng The latlng of the vertex\n   * @return {Number[][]} The cell coordinates of this vertex in the grid\n   */ \n  RouteBoxer.prototype.getCellCoords_ = function (latlng) {\n    for (var x = 0; this.lngGrid_[x] < latlng.lng(); x++) {}\n    for (var y = 0; this.latGrid_[y] < latlng.lat(); y++) {}\n    return ([x - 1, y - 1]);\n  };\n  \n  /**\n   * Find the cell a path vertex is in based on the known location of a nearby\n   *  vertex. This saves searching the whole grid when working through vertices\n   *  on the polyline that are likely to be in close proximity to each other.\n   *\n   * @param {LatLng[]} latlng The latlng of the vertex to locate in the grid\n   * @param {LatLng[]} hintlatlng The latlng of the vertex with a known location\n   * @param {Number[]} hint The cell containing the vertex with a known location\n   * @return {Number[]} The cell coordinates of the vertex to locate in the grid\n   */ \n  RouteBoxer.prototype.getGridCoordsFromHint_ = function (latlng, hintlatlng, hint) {\n    var x, y;\n    if (latlng.lng() > hintlatlng.lng()) {\n      for (x = hint[0]; this.lngGrid_[x + 1] < latlng.lng(); x++) {}\n    } else {\n      for (x = hint[0]; this.lngGrid_[x] > latlng.lng(); x--) {}\n    }\n    \n    if (latlng.lat() > hintlatlng.lat()) {\n      for (y = hint[1]; this.latGrid_[y + 1] < latlng.lat(); y++) {}\n    } else {        \n      for (y = hint[1]; this.latGrid_[y] > latlng.lat(); y--) {}\n    }\n    \n    return ([x, y]);\n  };\n  \n  \n  /**\n   * Identify the grid squares that a path segment between two vertices\n   * intersects with by:\n   * 1. Finding the bearing between the start and end of the segment\n   * 2. Using the delta between the lat of the start and the lat of each\n   *    latGrid boundary to find the distance to each latGrid boundary\n   * 3. Finding the lng of the intersection of the line with each latGrid\n   *     boundary using the distance to the intersection and bearing of the line\n   * 4. Determining the x-coord on the grid of the point of intersection\n   * 5. Filling in all squares between the x-coord of the previous intersection\n   *     (or start) and the current one (or end) at the current y coordinate,\n   *     which is known for the grid line being intersected\n   *     \n   * @param {LatLng} start The latlng of the vertex at the start of the segment\n   * @param {LatLng} end The latlng of the vertex at the end of the segment\n   * @param {Number[]} startXY The cell containing the start vertex\n   * @param {Number[]} endXY The cell containing the vend vertex\n   */ \n  RouteBoxer.prototype.getGridIntersects_ = function (start, end, startXY, endXY) {\n    var edgePoint, edgeXY, i;\n    var brng = start.rhumbBearingTo(end);         // Step 1.\n    \n    var hint = start;\n    var hintXY = startXY;\n    \n    // Handle a line segment that travels south first\n    if (end.lat() > start.lat()) {\n      // Iterate over the east to west grid lines between the start and end cells\n      for (i = startXY[1] + 1; i <= endXY[1]; i++) {\n        // Find the latlng of the point where the path segment intersects with\n        //  this grid line (Step 2 & 3)\n        edgePoint = this.getGridIntersect_(start, brng, this.latGrid_[i]);\n        \n        // Find the cell containing this intersect point (Step 4)\n        edgeXY = this.getGridCoordsFromHint_(edgePoint, hint, hintXY);\n        \n        // Mark every cell the path has crossed between this grid and the start,\n        //   or the previous east to west grid line it crossed (Step 5)\n        this.fillInGridSquares_(hintXY[0], edgeXY[0], i - 1);\n        \n        // Use the point where it crossed this grid line as the reference for the\n        //  next iteration\n        hint = edgePoint;\n        hintXY = edgeXY;\n      }\n      \n      // Mark every cell the path has crossed between the last east to west grid\n      //  line it crossed and the end (Step 5)\n      this.fillInGridSquares_(hintXY[0], endXY[0], i - 1);\n      \n    } else {\n      // Iterate over the east to west grid lines between the start and end cells\n      for (i = startXY[1]; i > endXY[1]; i--) {\n        // Find the latlng of the point where the path segment intersects with\n        //  this grid line (Step 2 & 3)\n        edgePoint = this.getGridIntersect_(start, brng, this.latGrid_[i]);\n        \n        // Find the cell containing this intersect point (Step 4)\n        edgeXY = this.getGridCoordsFromHint_(edgePoint, hint, hintXY);\n  \n        // Mark every cell the path has crossed between this grid and the start,\n        //   or the previous east to west grid line it crossed (Step 5)\n        this.fillInGridSquares_(hintXY[0], edgeXY[0], i);\n  \n        // Use the point where it crossed this grid line as the reference for the\n        //  next iteration\n        hint = edgePoint;\n        hintXY = edgeXY;\n      }\n      \n      // Mark every cell the path has crossed between the last east to west grid\n      //  line it crossed and the end (Step 5)\n      this.fillInGridSquares_(hintXY[0], endXY[0], i);\n      \n    }\n  };\n  \n  /**\n   * Find the latlng at which a path segment intersects with a given\n   *   line of latitude\n   *     \n   * @param {LatLng} start The vertex at the start of the path segment\n   * @param {Number} brng The bearing of the line from start to end\n   * @param {Number} gridLineLat The latitude of the grid line being intersected\n   * @return {LatLng} The latlng of the point where the path segment intersects\n   *                    the grid line\n   */ \n  RouteBoxer.prototype.getGridIntersect_ = function (start, brng, gridLineLat) {\n    var d = this.R * ((gridLineLat.toRad() - start.lat().toRad()) / Math.cos(brng.toRad()));\n    return start.rhumbDestinationPoint(brng, d);\n  };\n  \n  /**\n   * Mark all cells in a given row of the grid that lie between two columns\n   *   for inclusion in the boxes\n   *     \n   * @param {Number} startx The first column to include\n   * @param {Number} endx The last column to include\n   * @param {Number} y The row of the cells to include\n   */ \n  RouteBoxer.prototype.fillInGridSquares_ = function (startx, endx, y) {\n    var x;\n    if (startx < endx) {\n      for (x = startx; x <= endx; x++) {\n        this.markCell_([x, y]);\n      }\n    } else {\n      for (x = startx; x >= endx; x--) {\n        this.markCell_([x, y]);\n      }            \n    }      \n  };\n  \n  /**\n   * Mark a cell and the 8 immediate neighbours for inclusion in the boxes\n   *     \n   * @param {Number[]} square The cell to mark\n   */ \n  RouteBoxer.prototype.markCell_ = function (cell) {\n    var x = cell[0];\n    var y = cell[1];\n    this.grid_[x - 1][y - 1] = 1;\n    this.grid_[x][y - 1] = 1;\n    this.grid_[x + 1][y - 1] = 1;\n    this.grid_[x - 1][y] = 1;\n    this.grid_[x][y] = 1;\n    this.grid_[x + 1][y] = 1;\n    this.grid_[x - 1][y + 1] = 1;\n    this.grid_[x][y + 1] = 1;\n    this.grid_[x + 1][y + 1] = 1;\n  };\n  \n  /**\n   * Create two sets of bounding boxes, both of which cover all of the cells that\n   *   have been marked for inclusion.\n   *\n   * The first set is created by combining adjacent cells in the same column into\n   *   a set of vertical rectangular boxes, and then combining boxes of the same\n   *   height that are adjacent horizontally.\n   *\n   * The second set is created by combining adjacent cells in the same row into\n   *   a set of horizontal rectangular boxes, and then combining boxes of the same\n   *   width that are adjacent vertically.\n   *     \n   */ \n  RouteBoxer.prototype.mergeIntersectingCells_ = function () {\n    var x, y, box;\n    \n    // The box we are currently expanding with new cells\n    var currentBox = null;\n    \n    // Traverse the grid a row at a time\n    for (y = 0; y < this.grid_[0].length; y++) {\n      for (x = 0; x < this.grid_.length; x++) {\n        \n        if (this.grid_[x][y]) {\n          // This cell is marked for inclusion. If the previous cell in this\n          //   row was also marked for inclusion, merge this cell into it's box.\n          // Otherwise start a new box.\n          box = this.getCellBounds_([x, y]);\n          if (currentBox) {\n            currentBox.extend(box.getNorthEast());\n          } else {\n            currentBox = box;\n          }\n          \n        } else {\n          // This cell is not marked for inclusion. If the previous cell was\n          //  marked for inclusion, merge it's box with a box that spans the same\n          //  columns from the row below if possible.\n          this.mergeBoxesY_(currentBox);\n          currentBox = null;\n        }\n      }\n      // If the last cell was marked for inclusion, merge it's box with a matching\n      //  box from the row below if possible.\n      this.mergeBoxesY_(currentBox);\n      currentBox = null;\n    }\n  \n    // Traverse the grid a column at a time\n    for (x = 0; x < this.grid_.length; x++) {\n      for (y = 0; y < this.grid_[0].length; y++) {\n        if (this.grid_[x][y]) {\n          \n          // This cell is marked for inclusion. If the previous cell in this\n          //   column was also marked for inclusion, merge this cell into it's box.\n          // Otherwise start a new box.\n          if (currentBox) {\n            box = this.getCellBounds_([x, y]);\n            currentBox.extend(box.getNorthEast());\n          } else {\n            currentBox = this.getCellBounds_([x, y]);\n          }\n          \n        } else {\n          // This cell is not marked for inclusion. If the previous cell was\n          //  marked for inclusion, merge it's box with a box that spans the same\n          //  rows from the column to the left if possible.\n          this.mergeBoxesX_(currentBox);\n          currentBox = null;\n          \n        }\n      }\n      // If the last cell was marked for inclusion, merge it's box with a matching\n      //  box from the column to the left if possible.\n      this.mergeBoxesX_(currentBox);\n      currentBox = null;\n    }\n  };\n  \n  /**\n   * Search for an existing box in an adjacent row to the given box that spans the\n   * same set of columns and if one is found merge the given box into it. If one\n   * is not found, append this box to the list of existing boxes.\n   *\n   * @param {LatLngBounds}  The box to merge\n   */ \n  RouteBoxer.prototype.mergeBoxesX_ = function (box) {\n    if (box !== null) {\n      for (var i = 0; i < this.boxesX_.length; i++) {\n        if (this.boxesX_[i].getNorthEast().lng() === box.getSouthWest().lng() &&\n            this.boxesX_[i].getSouthWest().lat() === box.getSouthWest().lat() &&\n            this.boxesX_[i].getNorthEast().lat() === box.getNorthEast().lat()) {\n          this.boxesX_[i].extend(box.getNorthEast());\n          return;\n        }\n      }\n      this.boxesX_.push(box);\n    }\n  };\n  \n  /**\n   * Search for an existing box in an adjacent column to the given box that spans\n   * the same set of rows and if one is found merge the given box into it. If one\n   * is not found, append this box to the list of existing boxes.\n   *\n   * @param {LatLngBounds}  The box to merge\n   */ \n  RouteBoxer.prototype.mergeBoxesY_ = function (box) {\n    if (box !== null) {\n      for (var i = 0; i < this.boxesY_.length; i++) {\n        if (this.boxesY_[i].getNorthEast().lat() === box.getSouthWest().lat() &&\n            this.boxesY_[i].getSouthWest().lng() === box.getSouthWest().lng() &&\n            this.boxesY_[i].getNorthEast().lng() === box.getNorthEast().lng()) {\n          this.boxesY_[i].extend(box.getNorthEast());\n          return;\n        }\n      }\n      this.boxesY_.push(box);\n    }\n  };\n  \n  /**\n   * Obtain the LatLng of the origin of a cell on the grid\n   *\n   * @param {Number[]} cell The cell to lookup.\n   * @return {LatLng} The latlng of the origin of the cell.\n   */ \n  RouteBoxer.prototype.getCellBounds_ = function (cell) {\n    return new window.google.maps.LatLngBounds(\n      new window.google.maps.LatLng(this.latGrid_[cell[1]], this.lngGrid_[cell[0]]),\n      new window.google.maps.LatLng(this.latGrid_[cell[1] + 1], this.lngGrid_[cell[0] + 1]));\n  };\n  \n  /* Based on the Latitude/longitude spherical geodesy formulae & scripts\n     at http://www.movable-type.co.uk/scripts/latlong.html\n     (c) Chris Veness 2002-2010\n  */ \n  window.google.maps.LatLng.prototype.rhumbDestinationPoint = function (brng, dist) {\n    var R = 6371; // earth's mean radius in km\n    var d = parseFloat(dist) / R;  // d = angular distance covered on earth's surface\n    var lat1 = this.lat().toRad(), lon1 = this.lng().toRad();\n    brng = brng.toRad();\n  \n    var lat2 = lat1 + d * Math.cos(brng);\n    var dLat = lat2 - lat1;\n    var dPhi = Math.log(Math.tan(lat2 / 2 + Math.PI / 4) / Math.tan(lat1 / 2 + Math.PI / 4));\n    var q = (Math.abs(dLat) > 1e-10) ? dLat / dPhi : Math.cos(lat1);\n    var dLon = d * Math.sin(brng) / q;\n    // check for going past the pole\n    if (Math.abs(lat2) > Math.PI / 2) {\n      lat2 = lat2 > 0 ? Math.PI - lat2 : - (Math.PI - lat2);\n    }\n    var lon2 = (lon1 + dLon + Math.PI) % (2 * Math.PI) - Math.PI;\n   \n    if (isNaN(lat2) || isNaN(lon2)) {\n      return null;\n    }\n    return new window.google.maps.LatLng(lat2.toDeg(), lon2.toDeg());\n  };\n  \n  window.google.maps.LatLng.prototype.rhumbBearingTo = function (dest) {\n    var dLon = (dest.lng() - this.lng()).toRad();\n    var dPhi = Math.log(Math.tan(dest.lat().toRad() / 2 + Math.PI / 4) / Math.tan(this.lat().toRad() / 2 + Math.PI / 4));\n    if (Math.abs(dLon) > Math.PI) {\n      dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);\n    }\n    return Math.atan2(dLon, dPhi).toBrng();\n  };\n  \n  /**\n   * Extend the Number object to convert degrees to radians\n   *\n   * @return {Number} Bearing in radians\n   * @ignore\n   */ \n  Number.prototype.toRad = function () {\n    return this * Math.PI / 180;\n  };\n  \n  /**\n   * Extend the Number object to convert radians to degrees\n   *\n   * @return {Number} Bearing in degrees\n   * @ignore\n   */ \n  Number.prototype.toDeg = function () {\n    return this * 180 / Math.PI;\n  };\n  \n  /**\n   * Normalize a heading in degrees to between 0 and +360\n   *\n   * @return {Number} Return \n   * @ignore\n   */ \n  Number.prototype.toBrng = function () {\n    return (this.toDeg() + 360) % 360;\n  };\n\n  export default RouteBoxer;","import XLSX from 'xlsx';\nimport { writeFile } from 'fs';\n\nlet a = [{\n    \"name\" : 'Rohit tatu',\n    \"Age\" : 12 \n}]\n\n\n\nfunction createExcelWorkBook(title, subject, author){\n    let wb = XLSX.utils.book_new(); \n    wb.Props = {\n        Title : title,\n        Subject : subject,\n        Author : author,\n        CreatedDate : new Date()\n    };\n    return wb\n}\n\n\n\n\nexport default function from_json( data ) {\n    console.log(data)\n    console.log(Object.keys(data[0]))\n\n    let workBook = createExcelWorkBook('title', 'Subject', 'Rohit')\n    \n    let workSheet = XLSX.utils.json_to_sheet(data, {header: Object.keys(data[0]), skipHeader:false});\n\n    XLSX.utils.book_append_sheet(workBook, workSheet, 'Fuel Data')\n\n    let workBookOutput = XLSX.write( workBook,{bookType:'xlsx', type:'binary'})\n\n    // XLSX.writeFile(workBook, 'fuelData.xlsx')\n\n    return new Blob([stringToArrayBuffer(workBookOutput)], {\n        type:''\n    }, 'test.xlsx')\n}\n\nfunction stringToArrayBuffer(data){\n    let buffer = new ArrayBuffer(data.length);\n    let view = new Uint8Array(buffer);\n    for (var i=0; i!=data.length; ++i) view[i] = data.charCodeAt(i) & 0xFF;\n    return buffer;\n}","import React from 'react'\nimport { GoogleMap, Marker, withGoogleMap, DirectionsRenderer, InfoWindow } from \"react-google-maps\"\nimport Geosuggest from 'react-geosuggest';\nimport nearByMarker from './nearbyMarker'\nimport './App.sass'\nimport './geo.css'\nimport jsonFuel from './data/jsonFuel.json'\nimport from_json from './excelFromJson';\n\nconst data = [...jsonFuel.Cad, ...jsonFuel.Sheet2]\n\nconst MyMapComponent = withGoogleMap((props) => \n  <GoogleMap\n    defaultZoom={8}\n    defaultCenter={{ lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lng) }}\n  >\n    { props.isMarkerShown && props.marker && props.marker.map((item,index)=> \n        <Marker \n          key={index} \n          position={{ lat: item.lat, lng: item.lng }}\n          draggable={true}\n          onClick={()=>props.handleShowInfo(index,true)}\n        >\n        { props.showInfo === index && \n        <InfoWindow onCloseClick={()=>props.handleShowInfo(index, false)}>\n          <p>\n            <b>Site Id</b> : {`${item.site_id}`} <br />\n            <b>Address</b> : {`${item.Street}`} <br />\n            <b>Brand</b>   : {`${item.brand}`} <br />\n          </p>  \n          </InfoWindow>}\n    </Marker>\n    )}\n    { props.directions && <DirectionsRenderer directions={props.directions} />}\n  </GoogleMap>)\n\n\n\nclass MapContainer extends React.Component {\n\n    constructor(props){\n        super(props)\n        /**\n         * @param {from} source\n         * @param {to} destination\n         * @param {directions} route\n         * @param {distance} distance (in km)\n         * @param {marker} markerToBeShown\n         * @param {showInfo} indexOfMarkerToBeShown\n         */\n\n        /**\n         * @convert to json data\n         */\n        this.state = {\n          from:undefined,\n          to:undefined,\n          directions: undefined,\n          distance: 5,\n          marker:[...data],\n          showInfo:undefined,\n          href:'#'\n        }\n\n        \n    }\n    \n    handleSelect = (place,name) => \n      (name === \"from\") \n        ? (place) ? this.setState({from : place.location}) : this.setState({from:undefined})\n        : (place) ? this.setState({to:place.location}) : this.setState({to:undefined})\n\n    handleSearch = () => {\n      if(this.state.from && this.state.to && this.state.distance != '') {\n        this.handleDirection()\n      } else {\n        console.error('you are an idiot');\n      }\n    }\n\n    handleDirection = () => {\n      const DirectionsService = new window.google.maps.DirectionsService();\n      DirectionsService.route({\n        origin: new window.google.maps.LatLng(this.state.from),\n        destination: new window.google.maps.LatLng(this.state.to),\n        travelMode: window.google.maps.TravelMode.DRIVING,\n      }, (result, status) => {\n\n        if (status === window.google.maps.DirectionsStatus.OK) {\n          this.setState({       // set result of directions\n            directions: result,\n          },function(){\n            let marker = nearByMarker(data, (this.state.distance != '') ? parseFloat(this.state.distance) : 5, this.state.directions)\n            this.setState({marker:marker},function(){     // set result of markers\n              this.calculateData()\n            })  \n          });\n        } else {\n          console.log(result)\n          console.error(`error fetching directions ${result}`);\n        }\n      });\n    \n    }\n\n    handleShowInfo = (index, add) => {\n      (add) \n      ? this.setState({showInfo:index})\n      : this.setState({showInfo:undefined})\n    }\n\n    handleDistance = (event) => {\n      let value = parseFloat(event.target.value);\n      (value < 5 )\n      ? this.setState({distance:5})\n      : this.setState({distance:event.target.value})\n    }\n\n    calculateData = () => {\n      let source = [this.state.from];\n      let destinations = this.state.marker.map(item=>{return({lat:item.lat,lng:item.lng, site_id:item.site_id})})\n      let distanceService = new window.google.maps.DistanceMatrixService()\n\n      let total_location_length = destinations.length;\n      let total_location = []\n      let total_destination = []\n      let split_destination = []\n      while(destinations.length) {\n        split_destination.push(destinations.splice(0,25))\n      }\n\n      for(let i=0;i<split_destination.length;i++){\n        distanceService.getDistanceMatrix({\n          origins: source, \n          destinations: split_destination[i], \n          travelMode: window.google.maps.TravelMode.DRIVING\n        }, (res, status) => {\n          if(status == \"OK\") {\n            let destinations = res.rows[0].elements;\n            let destinationAddresses = res.destinationAddresses;\n\n            total_location = [...total_location, ...destinations]\n            total_location = total_location.map( (item, index) => {return({...item, site_id:split_destination[i][index].site_id})})\n            total_destination = [...total_destination, ...destinationAddresses]\n\n            if(total_location_length == total_location.length) {\n\n            total_location = total_location.map((item,index)=>{return({...item, Address:total_destination[index]})})\n            total_location.sort(function(a,b){\n              return a.distance.value - b.distance.value\n            })\n\n            total_location = total_location.map(item=>{return({distance:item.distance.text,duration:item.duration.text, Address:item.Address, Site_Id:item.site_id})})\n            this.exportToExcel(total_location);\n            }\n          }})\n      }\n\n    }\n\n    exportToExcel = ( exportData ) => {\n      let data = from_json(exportData)\n      this.setState({href:URL.createObjectURL(data)})   \n    }\n    \n\n    render(){\n        return(\n            <React.Fragment>\n                    <div className=\"container\">\n                        <div className=\"geo_container\">\n                            <label className=\"labelFor\">From</label>\n                            <Geosuggest \n                                onSuggestSelect={(place)=>this.handleSelect(place,'from')}\n                            />\n                        </div>\n                        <div className=\"geo_container\">\n                            <label className=\"labelFor\">To</label>\n                            <Geosuggest \n                                onSuggestSelect={(place)=>this.handleSelect(place,'to')}\n                            />\n                        </div>\n                        <div className=\"geo_container\">\n                            <label className=\"labelFor\">OffRoad Distance (in km)</label>\n                            <input \n                              type=\"number\" \n                              className=\"geosuggest__input\" \n                              placeholder=\"OffRoad Distance in km\" \n                              onChange={this.handleDistance} \n                              value={this.state.distance}\n                            />\n                        </div>\n                        <div className=\"geo_container\">\n                            <button onClick={this.handleSearch}>Search</button>\n                        </div>\n\n                        <div className=\"extra_options\">\n                          <a href={this.state.href} download={\"fuelData.xlsx\"}>Download Route Info</a>\n                        </div>   \n                    </div>\n                    <MyMapComponent\n                      isMarkerShown\n                      directions={this.state.directions}\n                      marker={this.state.marker}\n                      loadingElement={<div style={{ height: `100%` }} />}\n                      containerElement={<div style={{ height: `90vh` }} />}\n                      mapElement={<div style={{ height: `100%` }} />}\n                      showInfo={this.state.showInfo}\n                      handleShowInfo={this.handleShowInfo}\n                    />       \n            </React.Fragment>\n        )\n    }\n}\n\n\nexport default MapContainer;","import RouteBoxer from './RouterBox'\n\nexport default function nearByMarker(locations, distance, directions){\n\n    let containsMarker = []\n\n    let gmarkers = [];\n    let routeBoxer = new RouteBoxer();\n\n    locations.forEach(element => {\n        let marker = new window.google.maps.Marker({\n            title : element.brand,\n            position : new window.google.maps.LatLng(parseFloat(element.lat),parseFloat(element.lng)),\n            site_id : element.site_id,\n            Street : element.Street\n        })\n\n        gmarkers.push(marker)\n    });\n\n    console.log(gmarkers);\n\n    let path = directions.routes[0].overview_path\n\n    let boxes = routeBoxer.box(path, distance)\n\n    for (let i = 0; i < boxes.length; i++) {\n        \n        for(let j = 0; j < gmarkers.length; j++) {\n\n            if(boxes[i].contains(gmarkers[j].getPosition())){\n                containsMarker.push({\n                    lat : gmarkers[j].getPosition().lat(),\n                    lng : gmarkers[j].getPosition().lng(),\n                    Street: gmarkers[j].Street,\n                    site_id: gmarkers[j].site_id,\n                    brand: gmarkers[j].title\n                })\n            }\n        }\n        \n    }\n\n    console.log(containsMarker)\n    return containsMarker\n\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App'\n\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}